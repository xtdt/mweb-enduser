"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('zipkin'),
    Annotation = _require.Annotation,
    HttpHeaders = _require.HttpHeaders;
/**
 * @private
 * @param {string} name
 * @throws Error
 */


function requiredArg(name) {
  throw new Error("GrpcClientInstrumentation: Missing required argument ".concat(name, "."));
}
/**
 * @namespace grpc
 */

/**
 * @typedef {Object} grpc.Status
 * @memberof grpc
 * @property {function()} clone
 * @property {function(key: string, value: string)} add
 */

/**
 * @typedef {Object} grpc.Metadata
 * @memberof grpc
 * @property {function()} clone
 * @property {function(key: string, value: string)} add
 */

/**
 * @typedef {Object} GrpcClientContext
 * @property {zipkin.Tracer} tracer
 * @property {string} remoteServiceName
 */

/**
 * @class GrpcClientInstrumentation
 */


var GrpcClientInstrumentation = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Object} grpc
   * @param {GrpcClientContext} context
   */
  function GrpcClientInstrumentation(grpc, _ref) {
    var _ref$tracer = _ref.tracer,
        tracer = _ref$tracer === void 0 ? requiredArg('tracer') : _ref$tracer,
        remoteServiceName = _ref.remoteServiceName;

    _classCallCheck(this, GrpcClientInstrumentation);

    this.grpc = grpc;
    this.tracer = tracer;
    this.serviceName = tracer.localEndpoint.serviceName;
    this.remoteServiceName = remoteServiceName;
  }
  /**
   * Appends zipkin headers to gRPC metadata
   * @static
   * @param {grpc.Metadata} originalMetadata
   * @param {zipkin.TraceId} traceId
   * @return {grpc.Metadata}
   */


  _createClass(GrpcClientInstrumentation, [{
    key: "start",

    /**
     * Records start of RPC request
     * @param {grpc.Metadata} metadata
     * @param {string} method
     * @return {zipkin.TraceId}
     */
    value: function start(metadata, method) {
      var _this = this;

      var traceId = this.tracer.createChildId();
      this.tracer.letId(traceId, function () {
        _this.tracer.recordServiceName(_this.serviceName);

        _this.tracer.recordRpc(method);

        _this.tracer.recordAnnotation(new Annotation.ClientSend());

        if (_this.remoteServiceName) {
          _this.tracer.recordAnnotation(new Annotation.ServerAddr({
            serviceName: _this.remoteServiceName
          }));
        }
      });
      return traceId;
    }
    /**
     * Records end of RPC request
     * @param {zipkin.TraceId} traceId
     * @param {grpc.Status} status
     */

  }, {
    key: "onReceiveStatus",
    value: function onReceiveStatus(traceId, status) {
      var _this2 = this;

      var code = status.code; // TODO: In brave this is a string like UNKNOWN not a number

      this.tracer.letId(traceId, function () {
        if (code !== _this2.grpc.status.OK) {
          _this2.tracer.recordBinary('grpc.status_code', String(code));

          _this2.tracer.recordBinary('error', status.details || String(code));
        }

        _this2.tracer.recordAnnotation(new Annotation.ClientRecv());
      });
    }
  }], [{
    key: "setHeaders",
    value: function setHeaders(originalMetadata, traceId) {
      var metadata = originalMetadata.clone();
      metadata.add(HttpHeaders.TraceId, traceId.traceId);
      metadata.add(HttpHeaders.SpanId, traceId.spanId);
      traceId.parentSpanId.ifPresent(function (psid) {
        metadata.add(HttpHeaders.ParentSpanId, psid);
      });
      traceId.sampled.ifPresent(function (sampled) {
        metadata.add(HttpHeaders.Sampled, sampled ? '1' : '0');
      });

      if (traceId.isDebug()) {
        metadata.add(HttpHeaders.Flags, '1');
      }

      return metadata;
    }
  }]);

  return GrpcClientInstrumentation;
}();

module.exports = GrpcClientInstrumentation;